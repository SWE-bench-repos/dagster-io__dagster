---
description: Migrating factories to Components.
sidebar_position: 50
title: Migrating factories to Components
---

Itâ€™s common to encounter similar workflows in data engineering. In such cases, a modular approach is far more maintainable than duplicating code. With Dagster, a popular pattern is to use a factory function to dynamically generate related Dagster objects based on configuration rather than defining each one manually.

While factories are powerful and flexible, many patterns that use them can also be expressed using [components](/guides/build/components/).

## Factory

### 1. Define the factory function

Dagster factories are created like any standard Python factory function. They can generate any type of Dagster object (assets, jobs, schedules, etc.). The only requirement is that a Dagster factory must return a <PyObject section="definitions" module="dagster" object="Definitions" /> object containing all the parameterized objects it creates:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/asset_factory.py"
  language="python"
  startAfter="start_asset_factory"
  endBefore="end_asset_factory"
  title="src/<project_name>/defs/assets.py"
/>

This example factory takes a single parameter (`department`) and creates two linked assets based on the department name. Both assets are returned within a single <PyObject section="definitions" module="dagster" object="Definitions" /> object, which allows Dagster to register them as part of your project.

:::tip

When defining factories in Dagster, always use the `name` parameter to ensure all generated objects have unique and traceable names.

:::

### 2. Create the definition

Dagster factories must be initialized with configuration values (in this case the department names) in order to register their assets as part of your Dagster project. This is done by wrapping the factory in a standard Python using <PyObject section="definitions" module="dagster" object="Definitions" decorator />:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/asset_factory.py"
  language="python"
  startAfter="start_defs"
  endBefore="end_defs"
  title="src/<project_name>/defs/assets.py"
/>

### 3. View factory assets

The factory is now registered and its definitions can be viewed via the command line using `dg list defs`, or visually in the Dagster UI by running `dg dev`.

![Asset factory DAG](/images/migration/asset-factory.png)

## Component - single

### 1. Scaffold the component definition

When creating a new custom component in Dagster, the first step is to scaffold the component using `dg`. This generates the necessary boilerplate code and file structure for you to implement and register the component:

<CliInvocationExample contents="dg scaffold component AssetFactory" />

### 2. Define the component definition

Next, we define the component. This will look similar to the factory example above, but with a key difference: the departments attribute is defined at the class level, rather than passed as a parameter to a function.

Like the factory, the component should return a <PyObject section="definitions" module="dagster" object="Definitions" />  object containing all the generated assets. This enables Dagster to register and execute them as part of the project context:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/asset_factory_component_single.py"
  language="python"
  title="src/<project_name>/components/asset_factory.py"
/>

### 3. Configure the component

With the component registered, we can now use it in the project. The first step is to initialize the component:

<CliInvocationExample contents="dg scaffold defs 'my_project.components.asset_factory.AssetFactory' asset_factory" />

Next set the attributes of the component:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/defs_single.yaml"
  language="yaml"
  title="src/<project_name>/defs/asset_factory/defs.yaml"
/>

### 4. Viewing component assets

The assets generated by the initialized component behave the same as those created by the factory. You can view them in the command line with `dg list defs`, or interact with them in the Dagster UI by running `dg dev`.

![Asset factory DAG](/images/migration/asset-factory.png)

## Component - multiple

In the initial asset factory example, we passed a single `department` parameter. In contrast, the first component version used a list of `departments`. This allows a single component invocation to generate multiple asset instances.

It is possible to define a component that takes a single attribute (`department`) but you would then need to create a separate component instance for each value (e.g., one per department).

### 1. Scaffold the component definition

<CliInvocationExample contents="dg scaffold component AssetFactory" />

### 2. Define the component definition

The component code is very similar to the code where a list attribute was used. Though the loop is removed and will be handled by multiple usage of the component:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/asset_factory_component_multi.py"
  language="python"
  title="src/<project_name>/components/asset_factory.py"
/>

### 3. Configure the component

With the component registered, we can now use it in the project:

<CliInvocationExample contents="dg scaffold defs 'my_project.components.asset_factory.AssetFactory' asset_factory" />

Next set the attribute for same component three times:

<CodeExample
  path="docs_snippets/docs_snippets/migration/asset_factory/defs_multi.yaml"
  language="yaml"
  title="src/<project_name>/defs/asset_factory/defs.yaml"
/>